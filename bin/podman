#!/usr/bin/env ruby

class PodmanRunner
  DEFAULT_MACHINE = "podman-machine-default".freeze

  # external storage
  STORAGE = "/Volumes/OWC-Envoy-Pro-FX-4TB/podman".freeze
  TMPDIR = File.join(STORAGE, "tmp").freeze
  XDG_CONFIG_HOME = File.join(STORAGE, "config").freeze
  XDG_DATA_HOME = File.join(STORAGE, "data").freeze
  XDG_RUNTIME_DIR = File.join(STORAGE, "runtime").freeze

  def initialize(args)
    @args = args
    @exe = File.join(`brew --prefix`.chomp, "bin", "podman").freeze
  end

  def perform
    return init_machine if init_machine?
    run podman_command(*args)
  end

  private

  attr_reader :args, :exe

  def directories
    {TMPDIR:, XDG_CONFIG_HOME:, XDG_DATA_HOME:, XDG_RUNTIME_DIR:}
  end

  def podman_command(*args)
    "env #{directories.map { |k, v| "#{k}='#{v}'" }.join(" ")} #{exe} #{args.join(" ")}"
  end

  def exec(command)
    puts "➜ #{command}"
    Kernel.exec command
  end

  def run(command)
    puts "➜ #{command}"
    system command
  end

  def init_machine?
    args[0] == "machine" && args[1] == "init"
  end

  def init_machine
    unless `pgrep -f "Podman Desktop"`.strip.empty?
      puts "Close Podman Desktop before continuing!"
      exit 1
    end

    name = args[2..].last
    name = DEFAULT_MACHINE if name.nil? || name.empty? || name.start_with?("-")
    args.push name unless args.include?(name)

    puts <<~MSG
    WARNING: This will delete all existing data!
    DATA: #{STORAGE}
    #{"-".ljust(80, "-")}
    (Re)create the Podman VM #{name}? [yes/NO]
    MSG

    exit unless $stdin.gets.chomp.downcase == "yes"

    # cleanup
    puts "(RE)creating the Podman #{name} VM..."
    run podman_command("machine", "rm", "-f", name)
    run "rm -rf #{STORAGE}/*"

    #preparation
    directories.each_value { run "mkdir -p #{it}" }

    # create the machine
    run podman_command(*args)

    # fix the socket symlink
    socket = `#{podman_command("machine inspect --format '{{.ConnectionInfo.PodmanSocket.Path}}' #{name}")}`.chomp.split("\n").last
    exec "sudo ln -sf #{socket} /var/run/docker.sock"
  end
end

PodmanRunner.new(ARGV.dup).perform
